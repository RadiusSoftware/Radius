/*****
 * Copyright (c) 2017-2023 Kode Programming
 * https://github.com/KodeProgramming/kode/blob/main/LICENSE
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*****/


/*****
 * The subclass of HttpX that's the super class for all Radius framework web
 * applications.  The WebApp class provides the framework for handling messages,
 * API calls, application stability, security, transsction procerssing, and
 * transaction integrity.  Subclassing WebApp is how developers create their own
 * applications.  Note that the Webapp API is generated by adding a method to
 * the webapp objects.
*****/
define(class Webapp extends HttpX {
    constructor() {
        super();
    }

    async handleGET(handle) {
        let acceptLanguage = Object.keys(handle.req.getAcceptLanguage()).sort();
        let lang = await this.packages.getLanguage(this.getPackageName(), acceptLanguage);

        let webappSettings = {
            packageName: this.getPackageName(),
        };

        for (let key in this.getOptions()) {
            if (key != 'settings') {
                let option = this.getOption(key);
                webappSettings[key] = option;
            }
        }

        let html = this.htmlTemplate.toString({
            lang: lang,
            apiEndpoints: toJson(this.endpoints),
            radiusPath: this.radiusPath,
            webappSettings: mkBuffer(toJson(webappSettings)).toString('hex'),
        });

        handle.rsp.setHeader('Cache-Control', 'no-cache');

        if (handle.session.getToken()) {
            await handle.session.setData('parameters', handle.req.getParameters());
        }

        return {
            status: 200,
            mime: 'text/html',
            content: html,
        }
    }

    async handlePOST(handle) {
        if (handle.req.getMime() == 'application/json') {
            try {
                let message = await handle.req.getBody();

                let response = await this.api.call({
                    session: handle.session,
                    ishttp: true,
                    httpReq: handle.req,
                    httpRsp: handle.rsp,
                    message: message,
                });
                
                return {
                    status: 200,
                    mime: 'application/json',
                    content: toJson(response),
                };
            }
            catch (e) {
                await caught(e, req.getFullRequest(), req.getBody());
                return 500;
            }
        }
        else {
            return 422;
        }
    }

    async init() {
        await super.init();

        this.packages = mkPackageHandle();
        this.loadOrder = await this.listLoadOrder();
        this.radiusPath = await mkSettingsHandle().getSetting('radiusPath');

        let htmlPath = __filename.replace('.js', '.html');
        let htmlCode = (await FileSystem.readFile(htmlPath)).toString();
        this.htmlTemplate = mkTextTemplate(htmlCode);

        this.api = await mkApi(this).init();
        this.endpoints = mkBuffer(toJson(this.api.listEndpoints())).toString('hex');

        return this;
    }

    // ********************
    // getLoadorder
    // ********************
    async [Api.define(
        'getLoadOrder',
        {
        },
    )](trx) {
        return this.loadOrder;
    }

    // ********************
    // getPackage
    // ********************
    async [Api.define(
        'getPackage',
        {
            name: StringType,
            lang: StringType,
        },
    )](trx, name, lang) {
        let packages = mkPackageHandle();
        return await packages.getMozillaPackage(name, lang);
    }
});
